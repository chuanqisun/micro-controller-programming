<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Serial Port Monitor</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        align-items: center;
      }

      .status {
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 20px;
        font-weight: bold;
      }

      .status.disconnected {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }

      .status.connected {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .data-display {
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 1ch;
        background-color: #f8f9fa;
        font-family: "Courier New", monospace;
        overflow-y: auto;
      }

      .stats {
        display: flex;
        gap: 20px;
        margin-top: 10px;
        font-size: 12px;
        color: #6c757d;
      }

      .cube-container {
        margin-top: 20px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #000;
        position: relative;
        display: flex;
        justify-content: center;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Serial Port Monitor & 3D Cube Viewer</h1>

      <div class="controls">
        <button id="connectBtn" class="primary">Connect to Serial Port</button>
        <button id="disconnectBtn" class="danger" disabled>Disconnect</button>
        <button id="clearBtn" class="secondary">Clear Display</button>

        <select id="baudRate">
          <option value="9600">9600 baud</option>
          <option value="19200">19200 baud</option>
          <option value="38400">38400 baud</option>
          <option value="57600">57600 baud</option>
          <option value="115200" selected>115200 baud</option>
          <option value="230400">230400 baud</option>
          <option value="460800">460800 baud</option>
          <option value="921600">921600 baud</option>
        </select>
      </div>

      <div id="status" class="status disconnected">Status: Disconnected</div>

      <div id="dataDisplay" class="data-display">
        Pitch: <span id="pitchValue">0</span> | Yaw: <span id="yawValue">0</span> | Zoom: <span id="zoomValue">0</span>
      </div>

      <div class="stats">
        <span>Bytes received: <span id="bytesCount">0</span></span>
        <span>Lines: <span id="linesCount">0</span></span>
        <span>Connection time: <span id="connectionTime">--:--:--</span></span>
      </div>

      <div class="cube-container">
        <div id="cubeCanvas"></div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "https://esm.sh/three";

      class CubeRenderer {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.cube = null;
          this.animationId = null;

          this.currentZoom = 0;
          this.currentPitch = 0;
          this.currentYaw = 0;

          this.init();
        }

        init() {
          const container = document.getElementById("cubeCanvas");

          // Create scene
          this.scene = new THREE.Scene();

          // Create camera
          this.camera = new THREE.PerspectiveCamera(75, 600 / 400, 0.1, 1000);
          this.camera.position.z = 5;

          // Create renderer
          this.renderer = new THREE.WebGLRenderer({ antialias: true });
          this.renderer.setSize(600, 400);
          this.renderer.setClearColor(0x222222);
          container.appendChild(this.renderer.domElement);

          // Create cube
          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true,
            linewidth: 2,
          });
          this.cube = new THREE.Mesh(geometry, material);
          this.scene.add(this.cube);

          // Add some lighting for better visibility
          const light = new THREE.DirectionalLight(0xffffff, 1);
          light.position.set(1, 1, 1);
          this.scene.add(light);

          this.animate();
        }

        animate() {
          this.animationId = requestAnimationFrame(() => this.animate());

          // Update cube rotation based on serial data
          // Use the same scaling as Arduino code: 0.04 radians per unit
          const pitchScale = -0.04; // radians per unit (same as Arduino)
          const yawScale = 0.04; // radians per unit (same as Arduino)
          this.cube.rotation.x = this.currentPitch * pitchScale;
          this.cube.rotation.y = this.currentYaw * yawScale;

          // Update camera position based on zoom
          // Scale zoom value appropriately (assuming zoom range from Arduino)
          const zoomScale = 3 - this.currentZoom / 50; // Adjust scaling as needed
          this.camera.position.z = Math.max(1, Math.min(10, zoomScale));

          this.renderer.render(this.scene, this.camera);
        }

        updateValues(zoom, pitch, yaw) {
          this.currentZoom = zoom;
          this.currentPitch = pitch;
          this.currentYaw = yaw;

          // Update display values
          document.getElementById("zoomValue").textContent = zoom;
          document.getElementById("pitchValue").textContent = pitch;
          document.getElementById("yawValue").textContent = yaw;
        }

        destroy() {
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
          }
          if (this.renderer && this.renderer.domElement && this.renderer.domElement.parentNode) {
            this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
          }
        }
      }

      class SerialPortMonitor {
        constructor() {
          this.port = null;
          this.reader = null;
          this.isConnected = false;
          this.bytesReceived = 0;
          this.linesReceived = 0;
          this.connectionStartTime = null;
          this.connectionTimer = null;
          this.cubeRenderer = new CubeRenderer();

          this.initializeElements();
          this.bindEvents();
          this.checkWebSerialSupport();
        }

        initializeElements() {
          this.connectBtn = document.getElementById("connectBtn");
          this.disconnectBtn = document.getElementById("disconnectBtn");
          this.clearBtn = document.getElementById("clearBtn");
          this.baudRateSelect = document.getElementById("baudRate");
          this.statusDiv = document.getElementById("status");
          this.dataDisplay = document.getElementById("dataDisplay");
          this.bytesCount = document.getElementById("bytesCount");
          this.linesCount = document.getElementById("linesCount");
          this.connectionTimeSpan = document.getElementById("connectionTime");
        }

        bindEvents() {
          this.connectBtn.addEventListener("click", () => this.connect());
          this.disconnectBtn.addEventListener("click", () => this.disconnect());
          this.clearBtn.addEventListener("click", () => this.clearDisplay());
        }

        checkWebSerialSupport() {
          if (!("serial" in navigator)) {
            this.updateStatus("Web Serial API not supported in this browser", false);
            this.connectBtn.disabled = true;
            this.dataDisplay.textContent = "Web Serial API is not supported in this browser. Please use Chrome, Edge, or Opera.";
          }
        }

        async connect() {
          try {
            // Request a port and open the connection
            this.port = await navigator.serial.requestPort();

            const baudRate = parseInt(this.baudRateSelect.value);
            await this.port.open({
              baudRate: baudRate,
              dataBits: 8,
              stopBits: 1,
              parity: "none",
              flowControl: "none",
            });

            this.isConnected = true;
            this.connectionStartTime = Date.now();
            this.updateStatus(`Connected at ${baudRate} baud`, true);
            this.connectBtn.disabled = true;
            this.disconnectBtn.disabled = false;
            this.baudRateSelect.disabled = true;

            this.clearDisplay();
            this.startConnectionTimer();
            this.readSerialData();
          } catch (error) {
            console.error("Connection failed:", error);
            this.updateStatus(`Connection failed: ${error.message}`, false);
          }
        }

        async disconnect() {
          try {
            if (this.reader) {
              await this.reader.cancel();
              await this.reader.releaseLock();
              this.reader = null;
            }

            if (this.port) {
              await this.port.close();
              this.port = null;
            }

            this.isConnected = false;
            this.stopConnectionTimer();
            this.updateStatus("Disconnected", false);
            this.connectBtn.disabled = false;
            this.disconnectBtn.disabled = true;
            this.baudRateSelect.disabled = false;
          } catch (error) {
            console.error("Disconnect failed:", error);
          }
        }

        async readSerialData() {
          try {
            const decoder = new TextDecoderStream();
            const inputDone = this.port.readable.pipeTo(decoder.writable);
            const inputStream = decoder.readable;

            this.reader = inputStream.getReader();

            while (true) {
              const { value, done } = await this.reader.read();
              if (done) break;

              this.processData(value);
            }
          } catch (error) {
            if (error.name !== "AbortError") {
              console.error("Read error:", error);
              this.updateStatus(`Read error: ${error.message}`, false);
            }
          } finally {
            if (this.reader) {
              this.reader.releaseLock();
              this.reader = null;
            }
          }
        }

        processData(data) {
          // Update byte count
          this.bytesReceived += data.length;
          this.bytesCount.textContent = this.bytesReceived.toLocaleString();

          // Split data into lines
          const lines = data.split("\n");

          // Process each line (except empty ones)
          lines.forEach((line) => {
            if (line.trim()) {
              // Try to parse JSON data for cube control
              try {
                const jsonData = JSON.parse(line.trim());
                if (jsonData.hasOwnProperty("zoom") && jsonData.hasOwnProperty("pitch") && jsonData.hasOwnProperty("yaw")) {
                  // Update cube with parsed data
                  this.cubeRenderer.updateValues(jsonData.zoom, jsonData.pitch, jsonData.yaw);
                }
              } catch (e) {
                // Not JSON data, ignore for simplified display
              }

              this.linesReceived++;
            }
          });

          this.linesCount.textContent = this.linesReceived.toLocaleString();
        }

        clearDisplay() {
          // Reset values to 0 when clearing
          document.getElementById("pitchValue").textContent = "0";
          document.getElementById("yawValue").textContent = "0";
          document.getElementById("zoomValue").textContent = "0";

          this.bytesReceived = 0;
          this.linesReceived = 0;
          this.bytesCount.textContent = "0";
          this.linesCount.textContent = "0";
        }

        updateStatus(message, isConnected) {
          this.statusDiv.textContent = `Status: ${message}`;
          this.statusDiv.className = `status ${isConnected ? "connected" : "disconnected"}`;
        }

        startConnectionTimer() {
          this.connectionTimer = setInterval(() => {
            if (this.connectionStartTime) {
              const elapsed = Date.now() - this.connectionStartTime;
              const seconds = Math.floor(elapsed / 1000) % 60;
              const minutes = Math.floor(elapsed / 60000) % 60;
              const hours = Math.floor(elapsed / 3600000);

              const timeString = `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
              this.connectionTimeSpan.textContent = timeString;
            }
          }, 1000);
        }

        stopConnectionTimer() {
          if (this.connectionTimer) {
            clearInterval(this.connectionTimer);
            this.connectionTimer = null;
          }
          this.connectionTimeSpan.textContent = "--:--:--";
          this.connectionStartTime = null;
        }
      }

      // Initialize the serial port monitor when the page loads
      document.addEventListener("DOMContentLoaded", () => {
        window.serialMonitor = new SerialPortMonitor();
      });

      // Handle page unload to clean up connections
      window.addEventListener("beforeunload", async () => {
        if (window.serialMonitor && window.serialMonitor.isConnected) {
          await window.serialMonitor.disconnect();
        }
        if (window.serialMonitor && window.serialMonitor.cubeRenderer) {
          window.serialMonitor.cubeRenderer.destroy();
        }
      });
    </script>
  </body>
</html>
